# Файловый сервер для ESP32

## Оглавление
- [Описание проекта](#описание-проекта)
- [Особенности](#особенности)
- [Аппаратная конфигурация](#аппаратная-конфигурация)
- [Сетевой протокол](#сетевой-протокол)
- [Установка и сборка](#установка-и-сборка)
- [Конфигурация](#конфигурация)
- [Запуск и использование](#запуск-и-использование)
- [Лицензия](#лицензия)

## Описание проекта

Этот проект реализует TCP-файловый сервер на базе ESP32 с поддержкой загрузки (upload) и выгрузки (download) файлов через Wi-Fi. Для хранения файлов используется SD-карта по интерфейсу SPI, а для вывода системных сообщений подключён OLED-дисплей 128×64 по шине I2C.

## Особенности

* Загрузка и выгрузка файлов по TCP
* Ограничение имени файла: 8+"." + 3 символа расширения (формат 8.3)
* Хранение данных на SD-карте по SPI
* Отображение состояния на OLED-дисплее 128×64 по I2C
* Настраиваемые параметры SSID, пароль и пины периферии в `config.h`

## Аппаратная конфигурация

| Компонент   | Интерфейс | Пины по умолчанию                       |
| ----------- | --------- | --------------------------------------- |
| SD-карта    | SPI       | Настраивается в `main/include/config.h` |
| OLED 128×64 | I2C       | Настраивается в `main/include/config.h` |
| ESP32 Wi-Fi | UART/TCP  | SSID/PASSWORD в `main/include/config.h` |

## Сетевой протокол

Сервер ожидает специальные служебные пакеты для начала передачи данных.

### 1. Загрузка файла (Upload)

1. Клиент отправляет заголовок:

   ```text
   | 1B FLAG | 4B FILESIZE | 8B + 1B + 3B FileName |
   ```

   * FLAG: служебный код начала передачи
   * FILESIZE: размер файла в байтах (big-endian)
   * FileName: до 8 символов имени файла
   * ".": точка-разделитель
   * Extension: расширение (до 3 символов)
2. После приёма заголовка сервер ждёт пакет данных:

   ```text
   | 1B FLAG (0xDD) | up to 31B DATA |
   ```
3. Сервер записывает содержимое в файл на SD-карте по указанному имени.

### 2. Выгрузка файла (Download)

1. Клиент отправляет запрос:

   ```text
   | 1B FLAG | 8B + 1B + 3B FileName |
   ```
2. Сервер открывает файл и по уже открытому TCP-сокету отправляет данные файла.
3. Если файл не найден — сервер возвращает сообщение об ошибке и ждёт следующего служебного пакета.

## Установка и сборка

1. Клонируйте репозиторий:

   ```bash
   git clone https://github.com/warlcan/ESP32-TCP-FileServer.git
   ```
2. Перейдите в папку проекта:

   ```bash
   cd ESP32-TCP-FileServer
   ```
3. Настройте параметры в `main/include/config.h`:

   * Пины для SD-карты и OLED
   * SSID и PASSWORD вашей Wi-Fi сети
4. Соберите и прошейте прошивку:

   ```bash
   idf.py build
   idf.py -p <PORT> flash
   ```

## Конфигурация

Все настраиваемые параметры находятся в файле `main/include/config.h`:

* **Wi-Fi**

  ```c
  #define WIFI_SSID      "your-ssid"
  #define WIFI_PASSWORD  "your-password"
  ```
* **SD-карта (SPI)**

  ```c
  #define SD_MOSI_GPIO   23
  #define SD_MISO_GPIO   19
  #define SD_SCLK_GPIO   18
  #define SD_CS_GPIO     5
  ```
* **OLED-дисплей (I2C)**

  ```c
  #define I2C_SDA_GPIO   21
  #define I2C_SCL_GPIO   22
  ```

## Запуск и использование

1. После прошивки модуль подключится к Wi-Fi и начнёт слушать TCP-порт (по умолчанию 3333).
2. На OLED-дисплее отобразится IP-адрес ESP32.
3. Используйте TCP-клиент (например, `netcat` или собственный скрипт) для отправки служебных пакетов и данных.

Пример отправки через `netcat`:

```bash
# Загрузка файла
( printf "\xAA"; printf "$(printf '%08x' $FILESIZE)"; printf "myfile.txt"; cat file.bin ) | nc <ESP_IP> 3333

# Выгрузка файла
printf "\xBBmyfile.txt" | nc <ESP_IP> 3333 > downloaded.bin
```

> Замените `\xAA` и `\xBB` на реальные значения FLAG из кода проекта.

## Лицензия

MIT © 2025

```
```
